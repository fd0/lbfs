
Caching Client Implementation

consistency:
------------

close-to-open consistency is: on any close (CLOSE rpc), nfs client
flushes all changes to server; on any open (ACCESS rpc), nfs client
fetches latest attributes from server, and loads new data when the
cache time is less than mtime.

consistency
 0) don't update cache if cached file is dirty or being flushed
 1) if lease has not expired, and cache time matches mtime, use cache
 2) if lease has expired, fetch attribute; if cache time matches
    mtime, use cache
 3) if lease has expired, fetch attribute; if cache time does not
    match mtime, update cache

single user relaxed consistency: 
 - if mounted with "a" option, asynchrnous close is on. with
   asynchronous close a CLOSE is replied with OK before data are
   flushed to server. if during the flush server returned error, the
   cached file is marked as error and subsequent operations can no
   longer be performed on the cached file.


operations on cached file:
--------------------------

a cached file can be in one of the following four states

 IDLE
DIRTY: dirty, not flushed backed to server yet
FLUSH: in the middle of being flushed to server
FETCH: in the middle of being fetched from server

below is the state transition rule when different RPC occurs. X means
exception. i.e. the cached file should not be in this state when this
RPC occurs. XX means the RPC is blocked when the cached file is in
this state, and executed after the cached file changes state.

       ACCESS  FETCH_DONE   READ   WRITE   SETSIZE   CLOSE   FLUSH_DONE
-----------------------------------------------------------------------
 IDLE    IDLE    IDLE       IDLE   DIRTY   DIRTY     IDLE        X
DIRTY   DIRTY      X        DIRTY  DIRTY   DIRTY     FLUSH       X
FLUSH   FLUSH      X        FLUSH   XX      XX       FLUSH     IDLE
FETCH   FETCH      X      FETCH/XX  XX      XX       FETCH       X


detailed semantics:
-------------------

keeps both a negative lookup cache and a lookup cache. we intercept
RPC replies that may contain information that affect either cache. for
example, CREATE, REMOVE, MKDIR, etc.

fetch optimization: after each data block fetched from server, check
if any one of the read or write RPC can be executed. a RPC can run if
it operates on a range of the data already received from the server.

read optimization: can fetch data out of order, in order to satisfy an
out of order read request immediately.

attributes cache is shared code between sfslbcd and sfsrwcd. for
sfslbcd we keep our own file cache, and each file cache entry has an
attribute. attribute cache always reflects what the server knows about
a file; whereas attributes from the file cache may reflect changes yet
to be flushed to the server.

when a file is dirty or being flushed, GETATTR uses attribute from
file cache. in fact, we intercept ACCESS, GETATTR, SETATTR, and LOOKUP
replies and change the size attribute to that in the file cache.

write: on each write, update the size in file cache. always return
FILE_SYNC, because on CLOSE we commit everything on server.

close: send WRITE with UNSTABLE, then send COMMIT.

commit: since we return FILE_SYNC on each WRITE RPC, we should not see
any COMMIT RPCs unless they are for dangling WRITEs. so we just pass
them onto the server.

setattr: if size is changed, update size in file cache. forwards
setattr to server so other attributes are changed on server. we copy
the attributes returned from server to the file cache, but w/o
replacing the size and mtime fields.

wcc: wcc checking is done whenever we modify a file on server, via
WRITE, SETATTR, or COMMIT. the goal of doing wcc checking is to avoid
doing a file fetch on the next open if only one client is modifying
the file. because changes in ctime will not trigger a cache update, we
only check that the before and after size and mtime are the same, but
not ctime.

to make wcc work, "osize" field is kept for each cached object that
reflects the size of the object on server. as the size of the object
in cache changes, osize does not change. osize is updated when the
cached object is updated, flushed, or when setattr is processed (since
setattr is always forwarded to server)


misc:
-----

can we depend on nfs client to always send an ACCESS rpc before any
read? we don't do access control upon seeing a READ rpc: we just
return data from the cached file. if an user cannot access a file, the
ACCESS rpc will fail, and therefore no READ rpcs will be sent.

is it bad to evict from lrucache a file with an user count greater
than zero?

